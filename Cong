package com.rbs.bdd.application.service;

import com.rbs.bdd.application.exception.SchemaValidationException;
import com.rbs.bdd.application.port.out.AccountValidationPort;
import com.rbs.bdd.generated.ValidateArrangementForPaymentRequest;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import org.w3c.dom.Node;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;

/**
 * Service class responsible for validating SOAP request schema and applying business rules to static XML response.
 */
@Service
@RequiredArgsConstructor
public class AccountValidationService implements AccountValidationPort {

    private static final Logger logger = LoggerFactory.getLogger(AccountValidationService.class);

    /**
     * Automatically validates the request schema via Spring WS's interceptor.
     */
    @Override
    public void validateSchema(ValidateArrangementForPaymentRequest request) {
        logger.info("Schema validation completed (Spring WS handles XSD check)");
    }

    /**
     * Applies business rules to a static SOAP response XML file, modifies specific fields using DOM/XPath,
     * and writes the transformed XML directly to the outgoing SOAP message.
     *
     * @param request SOAP request containing operating brand
     * @param message Outgoing SOAP response to be written with modified static content
     */
    @Override
    public void validateBusinessRules(ValidateArrangementForPaymentRequest request, WebServiceMessage message) {
        try {
            logger.info("Starting business rule processing for operating brand: {}", request.getRequestHeader().getOperatingBrand());

            InputStream xml = getClass().getClassLoader().getResourceAsStream("static-response/response1.xml");
            if (xml == null) {
                throw new SchemaValidationException("response1.xml not found in classpath");
            }

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse(xml);

            XPath xpath = XPathFactory.newInstance().newXPath();

            // Modify dynamic values
            Node systemId = (Node) xpath.evaluate("//*[local-name()='responseId']/*[local-name()='systemId']", doc, XPathConstants.NODE);
            if (systemId != null) {
                systemId.setTextContent("ModifiedESP");
                logger.debug("Updated systemId");
            }

            Node transactionId = (Node) xpath.evaluate("//*[local-name()='responseId']/*[local-name()='transactionId']", doc, XPathConstants.NODE);
            if (transactionId != null) {
                transactionId.setTextContent("ModifiedTxn123");
                logger.debug("Updated transactionId");
            }

            // Write modified XML to SOAP response
            ByteArrayOutputStream rawOutput = new ByteArrayOutputStream();
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            transformer.transform(new DOMSource(doc), new StreamResult(rawOutput));

            SaajSoapMessage soapMessage = (SaajSoapMessage) message;
            soapMessage.getSaajMessage().getSOAPPart().setContent(
                new StreamSource(new ByteArrayInputStream(rawOutput.toByteArray()))
            );

            logger.info("SOAP response dynamically written from static XML template.");
        } catch (Exception e) {
            logger.error("Exception while processing business logic: {}", e.getMessage(), e);
            throw new SchemaValidationException("Error processing response XML", e);
        }
    }
}


--------/

<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>5.7.0</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.springframework.ws</groupId>
    <artifactId>spring-ws-core</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>


-------------
package com.rbs.bdd.application.service;

import com.rbs.bdd.application.exception.SchemaValidationException;
import com.rbs.bdd.generated.ObjectFactory;
import com.rbs.bdd.generated.RequestHeader;
import com.rbs.bdd.generated.ValidateArrangementForPaymentRequest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.springframework.ws.WebServiceMessage;

import javax.xml.soap.MessageFactory;
import java.io.ByteArrayOutputStream;

import static org.junit.jupiter.api.Assertions.*;

class AccountValidationServiceTest {

    private AccountValidationService service;

    @BeforeEach
    void setup() {
        service = new AccountValidationService();
    }

    @Test
    void shouldThrowExceptionIfXmlMissing() {
        ValidateArrangementForPaymentRequest request = new ObjectFactory().createValidateArrangementForPaymentRequest();
        WebServiceMessage mockMessage = createEmptySoapMessage();

        assertThrows(SchemaValidationException.class, () ->
            service.validateBusinessRules(request, mockMessage)
        );
    }

    @Test
    void shouldLogModifiedResponseSuccessfully() {
        // Pre-load your response1.xml in test/resources/static-response
        ValidateArrangementForPaymentRequest request = new ValidateArrangementForPaymentRequest();
        RequestHeader header = new RequestHeader();
        header.setOperatingBrand("ALL");
        request.setRequestHeader(header);

        WebServiceMessage message = createEmptySoapMessage();
        assertDoesNotThrow(() -> service.validateBusinessRules(request, message));
    }

    private WebServiceMessage createEmptySoapMessage() {
        try {
            return new SaajSoapMessage(MessageFactory.newInstance().createMessage());
        } catch (Exception e) {
            throw new RuntimeException("Failed to create test SOAP message", e);
        }
    }
}


-----------
/**
 * Entry port for handling SOAP requests related to payment validation.
 * Follows hexagonal architecture's `port in` pattern.
 */
public interface PaymentValidationPort {

    /**
     * Validates a payment arrangement request by delegating to the underlying orchestrator/service.
     *
     * @param request The SOAP request payload.
     * @param message The outgoing WebServiceMessage to be modified and returned.
     */
    void validateArrangementForPayment(ValidateArrangementForPaymentRequest request, WebServiceMessage message);

    // Future support: Retrieve customer functionality.
}


---------

/**
 * Defines the business contract for validating payment accounts.
 * Used by the orchestrator to call schema and business rule validators.
 */
public interface AccountValidationPort {

    /**
     * Performs XSD schema validation of the request. (Currently delegated to Spring WS config.)
     *
     * @param request The SOAP request payload.
     */
    void validateSchema(ValidateArrangementForPaymentRequest request);

    /**
     * Applies business rules on the static response XML based on request content,
     * and writes the final SOAP response directly to the output message.
     *
     * @param request The incoming SOAP request.
     * @param message The WebServiceMessage to write the modified response to.
     */
    void validateBusinessRules(ValidateArrangementForPaymentRequest request, WebServiceMessage message);
}


----------

/**
 * Service class responsible for orchestrating the validation flow of payment arrangement requests.
 * Implements {@link PaymentValidationPort} and delegates schema and business rule validation
 * to the appropriate output port.
 */
@Service
@RequiredArgsConstructor
public class PaymentOrchestrator implements PaymentValidationPort {

    private final AccountValidationPort accountValidationPort;

    /**
     * Entry point for handling the SOAP request. Validates schema and applies business rules.
     *
     * @param request the incoming SOAP request payload
     * @param message the SOAP WebServiceMessage used to write the final response
     */
    @Override
    public void validateArrangementForPayment(ValidateArrangementForPaymentRequest request, WebServiceMessage message) {
        accountValidationPort.validateSchema(request); // automatic validation through interceptor
        accountValidationPort.validateBusinessRules(request, message);
    }
}


----------

/**
 * Configuration class for setting up Spring WS infrastructure, including schema validation
 * and WSDL exposure. Implements {@link WsConfigurerAdapter}.
 */
@Configuration
@EnableWs
public class SoapWebServiceConfig extends WsConfigurerAdapter {

    /**
     * Registers the Spring WS {@link MessageDispatcherServlet}.
     *
     * @param context Spring ApplicationContext
     * @return ServletRegistrationBean for MessageDispatcherServlet
     */
    @Bean
    public ServletRegistrationBean<MessageDispatcherServlet> messageDispatcherServlet(ApplicationContext context) {
        MessageDispatcherServlet servlet = new MessageDispatcherServlet();
        servlet.setApplicationContext(context);
        servlet.setTransformWsdlLocations(true);
        return new ServletRegistrationBean<>(servlet, "/ws/*");
    }

    /**
     * Adds a schema validating interceptor to validate all incoming requests.
     *
     * @param interceptors list of Spring WS endpoint interceptors
     */
    @Override
    public void addInterceptors(List<EndpointInterceptor> interceptors) {
        PayloadValidatingInterceptor validatingInterceptor = new PayloadValidatingInterceptor();
        validatingInterceptor.setValidateRequest(true);
        validatingInterceptor.setValidateResponse(false);
        try {
            validatingInterceptor.setXsdSchemaCollection(updateContactXsd());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        interceptors.add(validatingInterceptor);
    }

    /**
     * Publishes the WSDL based on the XSD schema.
     *
     * @return DefaultWsdl11Definition for WSDL exposure
     * @throws Exception if schema loading fails
     */
    @Bean(name = "ArrValidationForPaymentParameters")
    public DefaultWsdl11Definition defaultWsdl11Definition() throws Exception {
        DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();
        wsdl11Definition.setPortTypeName("IArrValidationForPayment");
        wsdl11Definition.setLocationUri("/ws");
        wsdl11Definition.setTargetNamespace("http://com/rbsg/soa/C040PaymentManagement/ArrValidationForPayment/V01/");
        wsdl11Definition.setSchemaCollection(updateContactXsd());
        return wsdl11Definition;
    }

    /**
     * Loads and inlines the XSD schema used for validating SOAP requests.
     *
     * @return XsdSchemaCollection of all relevant XSDs
     * @throws Exception if schema loading fails
     */
    @Bean
    public XsdSchemaCollection updateContactXsd() throws Exception {
        CommonsXsdSchemaCollection xsd = new CommonsXsdSchemaCollection(
                new ClassPathResource("xsd/ArrValidationForPaymentParameters.xsd")
        );
        xsd.setInline(true);
        return xsd;
    }
}



------/--

/**
 * SOAP endpoint adapter class for handling the `validateArrangementForPayment` operation.
 * It uses Spring WS annotations to route incoming SOAP requests to the appropriate service layer.
 */
@Endpoint
public class PaymentValidationSoapAdapter {

    private static final String NAMESPACE_URI = "http://com/rbsg/soa/C040PaymentManagement/ArrValidationForPayment/V01/";

    private final PaymentValidationPort paymentValidationPort;

    /**
     * Constructor-based injection of the orchestrator that handles business logic.
     *
     * @param paymentValidationPort the orchestrator service
     */
    public PaymentValidationSoapAdapter(PaymentValidationPort paymentValidationPort) {
        this.paymentValidationPort = paymentValidationPort;
    }

    /**
     * Handles the `validateArrangementForPayment` SOAP request.
     * Delegates request processing to the orchestrator which modifies the response message directly.
     *
     * @param request the SOAP request payload
     * @param context the Spring WS message context
     */
    @PayloadRoot(namespace = NAMESPACE_URI, localPart = "validateArrangementForPayment")
    @ResponsePayload
    public void validateArrangementForPayment(@RequestPayload ValidateArrangementForPaymentRequest request,
                                              MessageContext context) {
        WebServiceMessage response = context.getResponse();
        paymentValidationPort.validateArrangementForPayment(request, response);
    }
}

------------











